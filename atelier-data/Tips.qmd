---
title: "Tips"
format:
  html:
    toc: true
    toc-location: right
    theme: cosmo
    css: styles.css
    code-copy: true
page-layout: full
execute:
  echo: true
  warning: false
  message: false
---

# Dplyr > data.table

```{r}
#| message: false
#| warning: false
# Charger les bibliothèques
library(dplyr)
library(data.table)
library(microbenchmark)
library(nycflights13)

# Charger les données
data(flights)
data(weather)

# Convertir les data.frames en data.tables
flightsdt <- as.data.table(flights)
weatherdt <- as.data.table(weather)

# Benchmark
result <- microbenchmark(
  dplyr = {
    output_dplyr <- flights %>%
      group_by(time_hour, origin) %>%
      summarise(arr_delay = mean(arr_delay, na.rm = TRUE),
                dep_delay = mean(dep_delay, na.rm = TRUE)) %>%
      ungroup() %>%
      inner_join(weather, by = c("time_hour", "origin"))
  },
  data.table = {
    output_DT <- merge(
      flightsdt[, .(arr_perc_delay = mean(arr_delay, na.rm = TRUE),
                    dep_perc_delay = mean(dep_delay, na.rm = TRUE)),
                by = .(time_hour, origin)],
      weatherdt,
      by = c("time_hour", "origin")
    )
  },
  times = 10L
)

# Afficher les résultats du benchmark
print(result)
```
Bon, soyons clair, data.table est (beaucoup) plus rapide que dplyr. Mais dplyr est plus lisible et permet plus de choses. Donc on le préferera pour une grande majorité de nos codes. Voir [dtplyr](https://www.tidyverse.org/blog/2019/11/dtplyr-1-0-0/), écris par l'équipe de Rstudio, il permet de traduire les requêtes dplyr en requêtes data.table. Ce n'est pas parfait mais ça peut sauver du temps sur les gros jeux de données.

# tibble > data.table > data.frame

Les tibbles sont des formes de data_frame plus stricts mais aussi plus verbeux. Par exemple, si on essaye de faire un `mutate` sur une colonne qui n'existe pas, on aura un message d'erreur plutôt que de créer une colonne avec des valeurs NA. Il n'a pas de rownames. Tout découpage rend un tibble (même s'il n'y a qu'une colonne ou une valeur).
De plus, les tibbles sont plus lisibles dans la console, car ils n'affichent que les colonnes qui tiennent sur l'écran, affichent les types de colonnes et uniquement les 10 premières lignes. Ils sont donc plus adaptés pour l'exploration de données.

```{r}
as.data.frame(weather) |> 
  head(50)
as_tibble(weather)
```

# Mettre des espaces après les *#*

... mettre des espaces après les *#*

```r
library(stringr)
walk(
  # Récupère tous les scripts du projet
  fs::dir_ls("R/", glob = "*.R", recurse = TRUE),
  
  function(file_path) {
    # Lire le contenu du script
    content <- read_file(file_path)

    # Ajouter un espace après les # de commentaire s'il n'y en a pas
    modified_content <- str_replace_all(content, "#\w", "# ")

    # Écrire le contenu modifié dans le fichier
    write_file(file_path, modified_content)
  }
)
```

# Commenter, commenter, commenter

Pour vous dans deux semaines ou pour quelqu'un d'autre, commentez votre code. Utilisez des commentaires pour expliquer les étapes importantes, les choix de conception, et les raisons derrière certaines décisions. Cela rendra votre code plus facile à comprendre et à maintenir.

# Quelques fonctions utiles

lag() et lead() sont des fonctions très utiles pour faire des décalages dans les données. Par exemple, si on veut calculer la variation d'une colonne par rapport à la ligne précédente, on peut utiliser lag(). lead() est l'inverse, il permet de décaler les données vers le haut.
